package net.ccbluex.liquidbounce.ui.client.clickgui.neverlose.moduleimport net.ccbluex.liquidbounce.LiquidBounceimport net.ccbluex.liquidbounce.ui.client.neverlose.Implimport net.ccbluex.liquidbounce.ui.client.neverlose.Mainimport net.ccbluex.liquidbounce.utils.render.RenderUtilsimport org.lwjgl.input.Mouseimport java.awt.Colorimport kotlin.math.absobject drawModule  {    fun drawModule(mouseX: Int, mouseY: Int, main: Main) {        when (Impl.theType) {            Impl.Type.CLIENT -> {                var lmodulesize = 0                var rmodulesize = 0                var line = 0                var line2 = 0                var positiony = 0                var positiony2 = 0                var modulesize = 0                main.modules = LiquidBounce.moduleManager.modules.filter {                    ((it.name.indexOf(Impl.Search) != -1 || it.name.toLowerCase().indexOf(Impl.Search) != -1 || it.name == Impl.Search || it.name.toLowerCase() == Impl.Search)                                   && Impl.Search.isNotEmpty()) || (it.category.displayName == Impl.selectedCategory && Impl.Search.isEmpty()) || (Impl.Search == "enabler" && it.state)                }                main.modules.forEachIndexed { index, module ->                    if (index % 2 == 0) {                        if (index == 2 * line) line++                        if (index - 2 >= 0) positiony += main.modules[index - 2].values.size + main.modules[index - 2].outvalue                        val positionX = 0                        val positionY = Impl.coordinateY.toInt() + 40 + (25 * line) + positiony * 20 + main.lwheeltranslate.y.toInt()                        if (positionY < Impl.coordinateY.toInt() + 325 && positionY + (module.values.size + module.outvalue) * 20 > Impl.coordinateY.toInt()) NModule.drawModule(                                       Impl.coordinateX.toInt() + 103 + positionX, positionY, mouseX, mouseY, module, main)                        lmodulesize++                    }                    if (index % 2 != 0) {                        if (index >= 1 * line2) line2++                        if (index - 2 >= 0) positiony2 += main.modules[index - 2].values.size + main.modules[index - 2].outvalue                        val positionX = 168                        val positionY = Impl.coordinateY.toInt() + 40 + (25 * line2) + positiony2 * 20 + main.rwheeltranslate.y.toInt()                        if (positionY < Impl.coordinateY.toInt() + 325 && positionY + (module.values.size + module.outvalue) * 20 > Impl.coordinateY.toInt()) NModule.drawModule(                                       Impl.coordinateX.toInt() + 103 + positionX, positionY, mouseX, mouseY, module, main)                        rmodulesize++                    }                }                try {                    val llastvaluesize = if (lmodulesize % 2 == 0) main.modules[main.modules.lastIndex - 1].values.size + main.modules[main.modules.lastIndex - 1].outvalue                    else main.modules[main.modules.size - 1].values.size + main.modules[main.modules.size - 1].outvalue                    val rlastvaluesize = if (rmodulesize % 2 == 0) main.modules[main.modules.size - 1].values.size + main.modules[main.modules.size - 1].outvalue                    else main.modules[main.modules.size - 2].values.size + main.modules[main.modules.size - 2].outvalue                    val lmax = line * 25 + positiony * 20 + if (llastvaluesize == 0) 50 else llastvaluesize * 20 + 50                    val rmax = line2 * 25 + positiony2 * 20 + if (rlastvaluesize == 0) 50 else rlastvaluesize * 20 + 50                    val maxWheel = lmax + rmax                    val idk = (285 - 85) * abs(main.lwheeltranslate.y + main.rwheeltranslate.y) / (maxWheel - (650 - (if (lmax < 350) 325 - lmax else 0 + if (rmax < 350) 325 - rmax else 0)))                    RenderUtils.drawRect(Impl.coordinateX + 431, Impl.coordinateY + 65, Impl.coordinateX + 433, Impl.coordinateY + 335,                                         Color(29, 35, 37).rgb)                    RenderUtils.drawRect(Impl.coordinateX + 431, Impl.coordinateY + 65 + idk, Impl.coordinateX + 433,                                         Impl.coordinateY + 50 + 85 + idk, Color(21, 96, 135).rgb)                    main.lwheeltranslate.translate(0f, Impl.lwheel)                    main.rwheeltranslate.translate(0f, Impl.rwheel)                    if (abs(Impl.lwheel) > lmax - 325 && lmax > 325) Impl.lwheel = -(lmax - 325f)                    if (abs(Impl.rwheel) > rmax - 325 && rmax > 325) Impl.rwheel = -(rmax - 325f)                    if (main.hovertoFloatL(Impl.coordinateX + 95f, Impl.coordinateY, Impl.coordinateX + 430f, Impl.coordinateY + 345f, mouseX, mouseY,                                      false)) {                        val dWheel = Mouse.getDWheel()                        if (lmax > 325) {                            for (i in 0 until 10) {                                if (dWheel < 0 && abs(Impl.lwheel) < lmax - 325) {                                    Impl.lwheel -= i                                }                                else if (dWheel > 0) {                                    Impl.lwheel += i                                    if (Impl.lwheel > 0) Impl.lwheel = 0f                                }                            }                        }                        if (rmax > 325) {                            for (i in 0 until 10) {                                if (dWheel < 0 && abs(Impl.rwheel) < rmax - 325) {                                    Impl.rwheel -= i                                }                                else if (dWheel > 0) {                                    Impl.rwheel += i                                    if (Impl.rwheel > 0) Impl.rwheel = 0f                                }                            }                        }                    }                } catch (e: IndexOutOfBoundsException) {                    e.printStackTrace()                }            }        }    }}