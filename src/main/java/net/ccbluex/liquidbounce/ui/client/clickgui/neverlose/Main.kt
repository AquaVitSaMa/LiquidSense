package net.ccbluex.liquidbounce.ui.client.neverloseimport me.aquavit.liquidsense.utils.render.RenderUtilsimport me.aquavit.liquidsense.utils.render.Translateimport net.ccbluex.liquidbounce.features.module.Moduleimport net.ccbluex.liquidbounce.features.module.ModuleCategoryimport net.ccbluex.liquidbounce.ui.client.clickgui.neverlose.About.aboutMainimport net.ccbluex.liquidbounce.ui.client.clickgui.neverlose.config.drawConfigimport net.ccbluex.liquidbounce.ui.client.clickgui.neverlose.implvalue.Editboximport net.ccbluex.liquidbounce.ui.client.clickgui.neverlose.implvalue.Editbox.newvalueimport net.ccbluex.liquidbounce.ui.client.clickgui.neverlose.module.drawModuleimport net.ccbluex.liquidbounce.ui.client.hud.designer.GuiHudDesignerimport net.ccbluex.liquidbounce.ui.client.neverlose.Impl.coordinateXimport net.ccbluex.liquidbounce.ui.client.neverlose.Impl.coordinateYimport net.ccbluex.liquidbounce.ui.client.neverlose.Impl.openmidmangerimport net.ccbluex.liquidbounce.ui.font.Fontsimport net.ccbluex.liquidbounce.ui.font.GameFontRendererimport net.ccbluex.liquidbounce.value.FloatValueimport net.ccbluex.liquidbounce.value.IntegerValueimport net.minecraft.client.gui.GuiScreenimport net.minecraft.client.gui.ScaledResolutionimport net.minecraft.client.renderer.GlStateManagerimport net.minecraft.util.ChatAllowedCharactersimport org.lwjgl.input.Keyboardimport org.lwjgl.input.Mouseimport org.lwjgl.opengl.GL11import java.awt.Colorimport java.text.SimpleDateFormatopen class Main : GuiScreen() {    var modules = emptyList<Module>()    private var rendercategory: ArrayList<Category> = ArrayList()    private var hovermove = false    private var ismove = false    private var lastmouseX = 0    private var lastmousey = 0    private var x = 0f    private var y = 0f    val lwheeltranslate = Translate(0f, 0f)    val rwheeltranslate = Translate(0f, 0f)    var mouseLDown = false    var mouseRDown = false    init {        var posy = 0        for (the in 0 until ModuleCategory.values().size) {            val categoryname = arrayOf("Ghost", "Misc", "Fun")            val expandName = arrayOf("Combat", "Utility", "Miscellaneous")            var expand = ""            var y = 18            for (index in 0..categoryname.lastIndex) if (ModuleCategory.values()[the].displayName == categoryname[index]) {                expand = expandName[index]                y = 30            }            val category = Category(23f, 50f + posy, ModuleCategory.values()[the], expand)            rendercategory.add(category)            posy += y        }    }    override fun drawScreen(mouseX: Int, mouseY: Int, tick: Float) {        drag(mouseX, mouseY)        RenderUtils.drawNLRect(coordinateX, coordinateY, coordinateX + 95f, coordinateY + 345f, 3f,                if (Impl.hue == "white") Color(240,245,248).rgb else if (Impl.hue == "black") Color(11, 11, 11).rgb else Color(6, 16, 28).rgb) //左侧矩形背景        RenderUtils.drawNLRect(coordinateX + 95f, coordinateY, coordinateX + 460f, coordinateY + 345f, 3f,                if (Impl.hue == "white") Color(255,255,255).rgb else if (Impl.hue == "black") Color(8, 8, 8).rgb else Color(7, 7, 11).rgb) //右侧矩形背景        RenderUtils.drawRect(coordinateX + 93f, coordinateY, coordinateX + 94f, coordinateY + 345f,                if (Impl.hue == "white") Color(213,213,213).rgb else if (Impl.hue == "black") Color(29,29,29).rgb else Color(16, 31, 33).rgb) //左侧矩形竖直线条        RenderUtils.drawRect(coordinateX + 94f, coordinateY, coordinateX + 97f, coordinateY + 345f,                if (Impl.hue == "white") Color(255,255,255).rgb else if (Impl.hue == "black") Color(8, 8, 8).rgb else Color(7, 7, 11).rgb) //左侧矩形竖直线条的右面        RenderUtils.drawRect(coordinateX + 93f, coordinateY + 34f, coordinateX + 460f, coordinateY + 35f,                if (Impl.hue == "white") Color(213,213,213).rgb else if (Impl.hue == "black") Color(29,29,29).rgb else Color(16, 31, 33).rgb) //设置条下面横线条        if (Impl.hue == "blue" || Impl.hue == "black" ) {            Fonts.bold26.drawString("liquidsense".toUpperCase(), coordinateX + 4, coordinateY + 13f, Color(11, 160, 255).rgb)            Fonts.font26.drawString("liquidsense".toUpperCase(), coordinateX + 5, coordinateY + 13f, Color(255, 255, 255).rgb)        } else Fonts.font26.drawString("liquidsense".toUpperCase(), coordinateX + 5, coordinateY + 13f, Color(51,51,51).rgb)        RenderUtils.drawShader(coordinateX + 5f, coordinateY + 280f, 84f, 20f)        RenderUtils.drawRect(coordinateX + 5f, coordinateY + 280f, coordinateX + 89f, coordinateY + 300f,                if (Impl.hue == "blue" || Impl.hue == "black" ) Color(4, 120, 176).rgb else Color(240,245,248).rgb)        Fonts.font20.drawCenteredString("CustomHUD", coordinateX + 45, coordinateY + 287f,                if (Impl.hue == "blue" || Impl.hue == "black" ) -1 else Color(1,1,1).rgb, false)        if (hoverConfig(coordinateX + 5f, coordinateY + 280, coordinateX + 90f, coordinateY + 305f, mouseX, mouseY, true)) mc.displayGuiScreen(                       GuiHudDesigner())        renderHead()        Fonts.font14.drawString("AquaVit", coordinateX + 37, coordinateY + 316,                if (Impl.hue == "blue" || Impl.hue == "black" ) -1 else Color(1,1,1).rgb)        Fonts.font14.drawString("Till:", coordinateX + 37, coordinateY + 328,                if (Impl.hue == "white") Color(140,140,140).rgb else if (Impl.hue == "black") Color(70,70,70).rgb else Color(46,67,81).rgb)        Fonts.font14.drawString(SimpleDateFormat("dd.MM").format(System.currentTimeMillis()) + " " + SimpleDateFormat("HH:mm").format(                       System.currentTimeMillis()), coordinateX + 52, coordinateY + 328, Color(2, 169, 245).rgb)        for (render in rendercategory) render.drawCategory(mouseX, mouseY, this)        //drawConfig.flie(mouseX, mouseY, this)        drawModule.drawModule(mouseX, mouseY, this)        Fonts.csgo40.drawString("G" , Impl.coordinateX + 410 , Impl.coordinateY + 14 , if (Impl.hue == "blue" || Impl.hue == "black" ) -1 else Color(1,1,1).rgb)        Fonts.csgo40.drawString("E", Impl.coordinateX + 395, Impl.coordinateY + 14, if (Impl.hue == "blue" || Impl.hue == "black" ) -1 else Color(1,1,1).rgb)        if (!openSearch) aboutMain.drawabout(mouseX, mouseY, this)        if (hoverConfig(Impl.coordinateX + 395, Impl.coordinateY + 14, Impl.coordinateX + 405, Impl.coordinateY + 26, mouseX, mouseY, true)) {            openSearch = !openSearch        }        if (openSearch) {            display++            RenderUtils.drawRectBordered(coordinateX + 290.0, coordinateY + 8.0, coordinateX + 420.0, coordinateY + 25.0, 1.0                    , if (Impl.hue == "white") Color(255,255,255).rgb else if (Impl.hue == "black") Color(8, 8, 8).rgb else Color(2, 5, 12).rgb                    , Color(16, 19, 26).rgb)            val search = if (display <= 100) Impl.Search + " |" else Impl.Search            drawText(search, 30, Fonts.font20, coordinateX.toInt() + 292, coordinateY.toInt() + 14                    , if (Impl.hue == "blue" || Impl.hue == "black" ) Color(255, 255, 255).rgb else Color(90, 90, 90).rgb)            if (display >= 200) display = 0        }        mouseLDown = Mouse.isButtonDown(0)        mouseRDown = Mouse.isButtonDown(1)        midclick = Mouse.isButtonDown(2)    }    var display = 0    override fun keyTyped(typedChar: Char, keyCode: Int) {        if (keyCode == Keyboard.KEY_ESCAPE && Editbox.value == null) {            mc.displayGuiScreen(null)        }        if (isCtrlKeyDown() && keyCode == Keyboard.KEY_F) openSearch = !openSearch        if (ChatAllowedCharacters.isAllowedCharacter(typedChar) && openSearch) {            Impl.Search = Impl.Search + typedChar            Impl.lwheel = 0f            Impl.rwheel = 0f        }        if (openSearch && keyCode == 14) {            if (checkall) {                Impl.Search = ""                checkall = false            }            else {                val length: Int = Impl.Search.length                if (length != 0) {                    Impl.Search = Impl.Search.substring(0, length - 1)                }            }        }        if (keyCode == 47 && isCtrlKeyDown() && !isShiftKeyDown() && !isAltKeyDown() && openSearch) Impl.Search += getClipboardString()        if (isCtrlKeyDown() && Keyboard.isKeyDown(Keyboard.KEY_A) && Impl.Search.length > 1) checkall = !checkall        try {            // 数值编辑器 intvalue flaotvalue            if (Editbox.value != null) {                // 删除字符串中的空格                if (newvalue.isNotEmpty()) newvalue.replace(" ", "")                val reset = keyCode == Keyboard.KEY_RETURN                if (Editbox.value is IntegerValue) {                    val value = (Editbox.value as IntegerValue)                    val max = value.maximum                    val min = value.minimum                    if (reset) {                        //判断设置的值 不是空的                        if (newvalue.isNotEmpty()) {                            val int = newvalue.toInt()                            //不能超过最大 不能小于最小                            value.value = if (int > max) max else if (int < min) min else int                            //设定成功自动关闭                            Editbox.value = null                        }                        // 如果是空的不设置 并且关闭                        else Editbox.value = null                    }                }                if (Editbox.value is FloatValue) {                    val value = (Editbox.value as FloatValue)                    val max = value.maximum                    val min = value.minimum                    if (reset) {                        //判断设置的值 不是空的                        if (newvalue.isNotEmpty()) {                            val flaot = newvalue.toFloat()                            //不能超过最大 不能小于最小                            value.value = if (flaot > max) max else if (flaot < min) min else flaot                            //设定成功自动关闭                            Editbox.value = null                        }                        // 如果是空的不设置 并且关闭                        else Editbox.value = null                    }                }                //排除按键                if (ChatAllowedCharacters.isAllowedCharacter(typedChar)) {                    // 绕过是floatvalue 就给打.                    val enabler = if (Editbox.value is FloatValue) "0123456789.-" else "0123456789-"                    for (e in enabler.toCharArray()) {                        //不给打第二个 . 号                        if (newvalue.indexOf(".") >= 1 && e.toString() == ".") continue                        // 排除不是特定按键                        if (typedChar == e) {                            // 判断这个字符串里面是不是有 . 号 没有就不执行 否则空指针                            if (newvalue.contains(".")) {                                // 截取发现 . 号的位置到最后面                                val string = newvalue.substring(newvalue.indexOf("."), newvalue.length).toCharArray()                                // -1是排除.号 floatvalue 后面的精确数值不能超过2位                                if (string.size - 1 < 2) {                                    newvalue += typedChar                                }                            }                            else {                                newvalue += typedChar                            }                        }                    }                }                //删除                if (keyCode == 14) {                    val length: Int = newvalue.length                    if (length != 0) newvalue = newvalue.substring(0, length - 1)                }                //取消                if (keyCode == Keyboard.KEY_ESCAPE) {                    Editbox.value = null                }            }        } catch (e: Exception) {            println("数值编辑器出错")            e.printStackTrace()        }    }    private var checkall = false    private var hoverSearch = false    var midclick = false    var openConfig = false    var openSearch = false    private fun renderHead() {        RenderUtils.drawRect(coordinateX, coordinateY + 305, coordinateX + 94, coordinateY + 306,                if (Impl.hue == "white") Color(213,213,213).rgb else if (Impl.hue == "black") Color(29,29,29).rgb else Color(16, 31, 33).rgb) //头像上条        GL11.glPushMatrix()        GL11.glTranslated(coordinateX + 4.0, coordinateY + 310.0, 0.0)        GL11.glColor3f(1f, 1f, 1f)        val playerInfo = mc.netHandler.getPlayerInfo(mc.thePlayer.uniqueID)        if (playerInfo != null) {            val locationSkin = playerInfo.locationSkin            mc.textureManager.bindTexture(locationSkin)            RenderUtils.drawScaledCustomSizeModalRect(2, 2, 8F, 8F, 8, 8, 25, 25, 64F, 64F)            GL11.glColor4f(1F, 1F, 1F, 1F)        }        for (i in 0..18) {            RenderUtils.drawCircle(14.5f, 14.75f, 12.5f + (0.275f * i), -180, 180,                    if (Impl.hue == "white") Color(240,245,248) else if (Impl.hue == "black") Color(11, 11, 11) else Color(6, 16, 28)) //MC头像包围圈            GlStateManager.resetColor()        }        GL11.glPopMatrix()    }    fun drag(mouseX: Int, mouseY: Int) {        if (hovertoFloatL(coordinateX, coordinateY, coordinateX + 95f, coordinateY + 35f, mouseX, mouseY, false) && Mouse.isButtonDown(0)) {            hovermove = true            if (!ismove) {                lastmouseX = mouseX                lastmousey = mouseY                x = coordinateX                y = coordinateY                ismove = true            }        }        if (hovermove) {            if (!Mouse.isButtonDown(0)) {                hovermove = false                ismove = false            }            else {                coordinateX = mouseX.toFloat() - (lastmouseX - x)                coordinateY = mouseY.toFloat() - (lastmousey - y)            }        }        //防止clickgui 移除屏幕        val scaledResolution = ScaledResolution(mc)        if (coordinateX <= 0) coordinateX = 0f        if (coordinateY <= 0) coordinateY = 0f        if (coordinateX + 460f >= scaledResolution.scaledWidth) coordinateX = scaledResolution.scaledWidth - 460f        if (coordinateY + 345f >= scaledResolution.scaledHeight) coordinateY = scaledResolution.scaledHeight - 345f    }    fun drawText(name: String, size: Int, font: GameFontRenderer, positionX: Int, positionY: Int, color: Int) {        var newstring = ""        val oldstring = name.toCharArray()        for (i in 0..oldstring.lastIndex) {            if (i < size) {                newstring += oldstring[i]            }        }        font.drawString(newstring, positionX, positionY, color)    }    fun drawText(name: String, size: Int, font: GameFontRenderer, positionX: Float, positionY: Float, color: Int) {        var newstring = ""        val oldstring = name.toCharArray()        for (i in 0..oldstring.lastIndex) {            if (i < size) {                newstring += oldstring[i]            }        }        font.drawString(newstring, positionX, positionY, color)    }    fun hovertoFloatL(xOne: Float, yOne: Float, xTwo: Float, yTwo: Float, mouseX: Int, mouseY: Int, click: Boolean): Boolean {        val hoverSystem = mouseX >= xOne && mouseX <= xTwo && mouseY >= yOne && mouseY <= yTwo        return ((click && !mouseLDown && Mouse.isButtonDown(0) && hoverSystem) || (!click && hoverSystem)) && !openConfig && !openmidmanger    }    fun hovertoFloatR(xOne: Float, yOne: Float, xTwo: Float, yTwo: Float, mouseX: Int, mouseY: Int, click: Boolean): Boolean {        val hoverSystem = mouseX >= xOne && mouseX <= xTwo && mouseY >= yOne && mouseY <= yTwo        return ((click && !mouseRDown && Mouse.isButtonDown(1) && hoverSystem) || (!click && hoverSystem)) && !openConfig && !openmidmanger    }    fun hoverConfig(xOne: Float, yOne: Float, xTwo: Float, yTwo: Float, mouseX: Int, mouseY: Int, click: Boolean): Boolean {        val hoverSystem = mouseX >= xOne && mouseX <= xTwo && mouseY >= yOne && mouseY <= yTwo        return ((click && !mouseLDown && Mouse.isButtonDown(0) && hoverSystem) || (!click && hoverSystem))    }}