package net.ccbluex.liquidbounce.ui.client.neverloseimport me.aquavit.liquidsense.utils.render.Translateimport net.ccbluex.liquidbounce.LiquidBounceimport net.ccbluex.liquidbounce.features.module.Moduleimport net.ccbluex.liquidbounce.features.module.ModuleCategoryimport net.ccbluex.liquidbounce.features.module.modules.render.ESPimport net.ccbluex.liquidbounce.ui.client.miscible.MElementimport net.ccbluex.liquidbounce.ui.client.neverlose.Impl.confignameimport net.ccbluex.liquidbounce.ui.client.neverlose.Impl.coordinateXimport net.ccbluex.liquidbounce.ui.client.neverlose.Impl.coordinateYimport net.ccbluex.liquidbounce.ui.client.neverlose.Impl.lwheelimport net.ccbluex.liquidbounce.ui.client.neverlose.Impl.rwheelimport net.ccbluex.liquidbounce.ui.font.Fontsimport net.ccbluex.liquidbounce.ui.font.GameFontRendererimport net.ccbluex.liquidbounce.utils.render.RenderUtilsimport net.minecraft.client.gui.GuiScreenimport net.minecraft.client.renderer.GlStateManagerimport org.lwjgl.input.Mouseimport org.lwjgl.opengl.GL11import java.awt.Colorimport java.io.Fileimport kotlin.math.absclass Main : GuiScreen() {    var modules = emptyList<Module>()    private var rendercategory: ArrayList<Category> = ArrayList()    private var hovermove = false    private var ismove = false    private var lastmouseX = 0    private var lastmousey = 0    private var x = 0f    private var y = 0f    val lwheeltranslate = Translate(0f, 0f)    val rwheeltranslate = Translate(0f, 0f)    init {        var posy = 0        for (the in 0 until ModuleCategory.values().size) {            val category = Category(23f, 50f + posy, ModuleCategory.values()[the])            rendercategory.add(category)            posy+= (if(ModuleCategory.values()[the].displayName == "Misc") 30 else 18)        }    }    private fun renderHead() {        RenderUtils.drawRect(coordinateX , coordinateY + 305 , coordinateX + 94 , coordinateY + 306 , Color(16,31,33).rgb)        GL11.glPushMatrix()        GL11.glTranslated(coordinateX + 10.0, coordinateY + 310.0, 0.0)        GL11.glColor3f(1f, 1f, 1f)        val playerInfo = mc.netHandler.getPlayerInfo(mc.thePlayer.uniqueID)        if (playerInfo != null) {            val locationSkin = playerInfo.locationSkin            mc.textureManager.bindTexture(locationSkin)            RenderUtils.drawScaledCustomSizeModalRect(2, 2, 8F, 8F, 8, 8, 25, 25, 64F, 64F)            GL11.glColor4f(1F, 1F, 1F, 1F)        }        for (i in 0..18) {            RenderUtils.drawCircle(14.5f , 14.75f, 12.5f + (0.275f * i), -180, 180, Color(6,16,28))            GlStateManager.resetColor()        }        GL11.glPopMatrix()    }    override fun drawScreen(mouseX: Int, mouseY: Int, tick: Float) {        if (hovertoFloatL(coordinateX, coordinateY, coordinateX + 95f, coordinateY + 35f, mouseX, mouseY, false) && Mouse.isButtonDown(0)) {            hovermove = true            if (!ismove) {                lastmouseX = mouseX                lastmousey = mouseY                x = coordinateX                y = coordinateY                ismove = true            }        }        if (hovermove) {            if (!Mouse.isButtonDown(0)) {                hovermove = false                ismove = false            }            else {                coordinateX = mouseX.toFloat() - (lastmouseX - x)                coordinateY = mouseY.toFloat() - (lastmousey - y)            }        }        RenderUtils.drawNLRect(coordinateX, coordinateY, coordinateX + 95f, coordinateY + 345f, 3f, Color(6, 16, 28).rgb)        RenderUtils.drawNLRect(coordinateX + 95f, coordinateY, coordinateX + 435f, coordinateY + 345f, 3f, Color(7, 7, 11).rgb)        RenderUtils.drawRect(coordinateX + 93f, coordinateY, coordinateX + 94f, coordinateY + 345f, Color(16, 31, 33).rgb)        RenderUtils.drawRect(coordinateX + 94f, coordinateY, coordinateX + 97f, coordinateY + 345f, Color(7, 7, 11).rgb)        RenderUtils.drawRect(coordinateX + 93f, coordinateY + 34f, coordinateX + 435f, coordinateY + 35f, Color(16, 31, 33).rgb)        Fonts.font25.drawString("liquidsense".toUpperCase(), coordinateX + 5.5f, coordinateY + 13f, Color(11, 160, 255).rgb)        Fonts.font25.drawString("liquidsense".toUpperCase(), coordinateX + 6, coordinateY + 13f, -1)        renderHead()       /* RenderUtils.drawCircleRect(coordinateX + 5f, coordinateY + 280, coordinateX + 90f, coordinateY + 305f, 3f, Color(4, 120, 176).rgb)        Fonts.font18.drawString("Manager".toUpperCase(), coordinateX + 25, coordinateY + 291f, -1)        if (hoverConfig(coordinateX + 5f, coordinateY + 280, coordinateX + 90f, coordinateY + 305f, mouseX, mouseY, true)) {            Impl.theType = Impl.Type.Manager        }*/        for (render in rendercategory) render.drawCategory(mouseX, mouseY, this)        when (Impl.theType) {            Impl.Type.CLIENT -> {                var lmodulesize = 0                var rmodulesize = 0                var line = 0                var line2 = 0                var positiony = 0                var positiony2 = 0                var modulesize = 0                modules = LiquidBounce.moduleManager.modules.filter { it.category.displayName == Impl.selectedCategory }                modules.forEachIndexed { index, module ->                    if (index % 2 == 0) {                        if (index == 2 * line) line++                        if (index - 2 >= 0) positiony += modules[index - 2].values.size + modules[index - 2].outvalue                        val positionX = 0                        val positionY = coordinateY.toInt() + 40 + (25 * line) + positiony * 20 + lwheeltranslate.y.toInt()                        if (positionY < coordinateY.toInt() + 325 && positionY + (module.values.size + module.outvalue) * 20 > coordinateY.toInt()) NModule.drawModule(                                       coordinateX.toInt() + 103 + positionX, positionY, mouseX, mouseY, module, this)                        lmodulesize++                    }                    if (index % 2 != 0) {                        if (index >= 1 * line2) line2++                        if (index - 2 >= 0) positiony2 += modules[index - 2].values.size + modules[index - 2].outvalue                        val positionX = 168                        val positionY = coordinateY.toInt() + 40 + (25 * line2) + positiony2 * 20 + rwheeltranslate.y.toInt()                        if (positionY < coordinateY.toInt() + 325 && positionY + (module.values.size + module.outvalue) * 20 > coordinateY.toInt()) NModule.drawModule(                                       coordinateX.toInt() + 103 + positionX, positionY, mouseX, mouseY, module, this)                        rmodulesize ++                    }                    modulesize++                }                try {                    val llastvaluesize = if (modulesize % 2 == 0) modules[modules.lastIndex - 1].values.size + modules[modules.lastIndex - 1].outvalue                    else modules[modules.size - 1].values.size + modules[modules.size - 1].outvalue                    val rlastvaluesize = if (modulesize % 2 == 0) modules[modules.size - 1].values.size + modules[modules.size - 1].outvalue                    else modules[modules.size - 2].values.size + modules[modules.size - 2].outvalue                    val lmax = line * 25 + positiony * 20 + if (llastvaluesize == 0) 50 else llastvaluesize * 20 + 50                    val rmax = line2 * 25 + positiony2 * 20 + if (rlastvaluesize == 0) 50 else rlastvaluesize * 20 + 50                    val maxWheel =  lmax + rmax                    val idk = (285 - 85) * abs(lwheeltranslate.y + rwheeltranslate.y) / (maxWheel - (650 -                                   (if(lmax < 350) 325 -  lmax else 0  +  if(rmax < 350) 325 - rmax else 0)))                    RenderUtils.drawRect(coordinateX + 431, coordinateY + 65, coordinateX + 433, coordinateY + 335, Color(29, 35, 37).rgb)                    RenderUtils.drawRect(coordinateX + 431, coordinateY + 65 + idk, coordinateX + 433,                                         coordinateY + 50 +  85 + idk, Color(21, 96, 135).rgb)                    lwheeltranslate.translate(0f, lwheel)                    rwheeltranslate.translate(0f, rwheel)                    if (abs(lwheel) > lmax - 325 && lmax > 325) lwheel = -(lmax - 325f)                    if (abs(rwheel) > rmax - 325 && rmax > 325) rwheel = -(rmax - 325f)                    if (hovertoFloatL(coordinateX + 95f, coordinateY, coordinateX + 430f, coordinateY + 345f, mouseX, mouseY, false)) {                        val dWheel = Mouse.getDWheel()                        if (lmax > 325) {                            for (i in 0 until 10) {                                if (dWheel < 0 && abs(lwheel) < lmax - 325) {                                    lwheel -= i                                }                                else if (dWheel > 0) {                                    lwheel += i                                    if (lwheel > 0) lwheel = 0f                                }                            }                        }                        if (rmax > 325) {                            for (i in 0 until 10) {                                if (dWheel < 0 && abs(rwheel) < rmax - 325) {                                    rwheel -= i                                }                                else if (dWheel > 0) {                                    rwheel += i                                    if (rwheel > 0) rwheel = 0f                                }                            }                        }                    }                } catch (e: IndexOutOfBoundsException) {                    e.printStackTrace()                }            }        }        flie(mouseX, mouseY)        /*        val Previewmodule = LiquidBounce.moduleManager[RenderChanger::class.java]!!.state || LiquidBounce.moduleManager[Chams::class.java]!!.state        if(Previewmodule) {            RenderUtils.drawNLRect(coordinateX + 450f, coordinateY, coordinateX + 550f, coordinateY + 120, 3f, Color(7, 7, 11).rgb)            ModelRender.draw(coordinateX + 500f, coordinateY + 110)        }         */        mouseLDown = Mouse.isButtonDown(0)        mouseRDown = Mouse.isButtonDown(1)    }    private var openConfig = false    fun flie(mouseX: Int, mouseY: Int) {        val file: Array<File>? = LiquidBounce.fileManager.settingsDir.listFiles()        val settings = file ?: return        // Save background        val hoverSave = hoverConfig(coordinateX + 105, coordinateY + 8, coordinateX + 153, coordinateY + 25, mouseX, mouseY, false)        RenderUtils.drawRectBordered(coordinateX + 105.0, coordinateY + 8.0, coordinateX + 153.0, coordinateY + 25.0, 0.5,                                     if (hoverSave) Color(15, 13, 18).rgb else Color(9, 8, 12).rgb, Color(16, 19, 26).rgb)        Fonts.font17.drawString("Save", coordinateX + 131f, coordinateY + 15f, Color(200, 200, 200).rgb)        if (hoverSave && !mouseLDown && Mouse.isButtonDown(0)) {            LiquidBounce.commandManager.executeCommands("${LiquidBounce.commandManager.prefix}localsetting save ${Impl.configname} all")        }        // config background        RenderUtils.drawRectBordered(coordinateX + 160.0, coordinateY + 8.0, coordinateX + 230.0,                                     coordinateY + 25.0 + if (openConfig) (settings.size * 15) else 0, 0.5, Color(2, 5, 12).rgb,                                     Color(16, 19, 26).rgb)        // load background        val hoverload = hoverConfig(coordinateX + 237f, coordinateY + 8f, coordinateX + 285f, coordinateY + 25f, mouseX, mouseY, false)        RenderUtils.drawRectBordered(coordinateX + 237.0, coordinateY + 8.0, coordinateX + 285.0, coordinateY + 25.0, 0.5,                                     if (hoverload) Color(8, 15, 24).rgb else Color(2, 5, 12).rgb, Color(16, 19, 26).rgb)        if (hoverload && !mouseLDown && Mouse.isButtonDown(0)) {            LiquidBounce.commandManager.executeCommands("${LiquidBounce.commandManager.prefix}localsetting load ${Impl.configname}")        }        Fonts.font17.drawString("Load", coordinateX + 257f, coordinateY + 15f, Color(200, 200, 200).rgb)        drawText(Impl.configname, 13, Fonts.font17, coordinateX.toInt() + 163, coordinateY.toInt() + 15, Color(200, 200, 200).rgb)        if (hoverConfig(coordinateX + 160f, coordinateY + 10f, coordinateX + 230f, coordinateY + 25f, mouseX, mouseY, true)) {            openConfig = !openConfig        }        if (openConfig) {            var fileHight = 0            for (json in settings) {                val hover =                    hoverConfig(coordinateX + 160f, coordinateY + 25f + fileHight, coordinateX + 230f, coordinateY + 40f + fileHight, mouseX, mouseY,                                false)                if (hoverConfig(coordinateX + 160f, coordinateY + 25f + fileHight, coordinateX + 230f, coordinateY + 40f + fileHight, mouseX, mouseY,                                true)) {                    Impl.configname = json.name                    openConfig = !openConfig                }                if (hover) RenderUtils.drawRect(coordinateX + 160.0, coordinateY + 25.0 + fileHight, coordinateX + 230.0,                                                coordinateY + 40.0 + fileHight, Color(16, 19, 26).rgb)                drawText(json.name, 13, Fonts.font16, coordinateX.toInt() + 163, coordinateY.toInt() + 31 + fileHight, Color(200, 200, 200).rgb)                fileHight += 15            }        }    }    fun drawText(name: String, size: Int, font: GameFontRenderer, positionX: Int, positionY: Int, color: Int) {        var newstring = ""        val oldstring = name.toCharArray()        for (i in 0..oldstring.lastIndex) {            if (i < size) {                newstring += oldstring[i]            }        }        font.drawString(newstring, positionX, positionY, color)    }    var mouseLDown = false    var mouseRDown = false    fun hovertoFloatL(xOne: Float, yOne: Float, xTwo: Float, yTwo: Float, mouseX: Int, mouseY: Int, click: Boolean): Boolean {        val hoverSystem = mouseX >= xOne && mouseX <= xTwo && mouseY >= yOne && mouseY <= yTwo        return ((click && !mouseLDown && Mouse.isButtonDown(0) && hoverSystem) || (!click && hoverSystem)) && !openConfig    }    fun hovertoFloatR(xOne: Float, yOne: Float, xTwo: Float, yTwo: Float, mouseX: Int, mouseY: Int, click: Boolean): Boolean {        val hoverSystem = mouseX >= xOne && mouseX <= xTwo && mouseY >= yOne && mouseY <= yTwo        return ((click && !mouseRDown && Mouse.isButtonDown(1) && hoverSystem) || (!click && hoverSystem)) && !openConfig    }    fun hoverConfig(xOne: Float, yOne: Float, xTwo: Float, yTwo: Float, mouseX: Int, mouseY: Int, click: Boolean): Boolean {        val hoverSystem = mouseX >= xOne && mouseX <= xTwo && mouseY >= yOne && mouseY <= yTwo        return ((click && !mouseLDown && Mouse.isButtonDown(0) && hoverSystem) || (!click && hoverSystem))    }}