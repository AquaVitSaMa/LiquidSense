package me.aquavit.liquidsense.module.modules.exploit;

import me.aquavit.liquidsense.event.EventTarget;
import me.aquavit.liquidsense.event.events.PacketEvent;
import me.aquavit.liquidsense.event.events.UpdateEvent;
import me.aquavit.liquidsense.module.Module;
import me.aquavit.liquidsense.module.ModuleCategory;
import me.aquavit.liquidsense.module.ModuleInfo;
import me.aquavit.liquidsense.utils.timer.TimeUtils;
import me.aquavit.liquidsense.value.IntegerValue;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C00PacketKeepAlive;
import net.minecraft.network.play.client.C0FPacketConfirmTransaction;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

@ModuleInfo(name = "PingSpoof", description = "Spoofs your ping to a given value.", category = ModuleCategory.EXPLOIT)
public class PingSpoof extends Module {
	private final IntegerValue maxDelayValue = new IntegerValue("MaxDelay", 1000, 0, 5000) {
		@Override
		protected void onChanged(final Integer oldValue, final Integer newValue) {
			final int minDelayValue = PingSpoof.this.minDelayValue.get();

			if(minDelayValue > newValue)
				set(minDelayValue);
		}
	};

	private final IntegerValue minDelayValue = new IntegerValue("MinDelay", 500, 0, 5000) {

		@Override
		protected void onChanged(final Integer oldValue, final Integer newValue) {
			final int maxDelayValue = PingSpoof.this.maxDelayValue.get();

			if(maxDelayValue < newValue)
				set(maxDelayValue);
		}
	};

	private final HashMap<Packet<?>, Long> packetsMap = new HashMap<>();

	@Override
	public void onDisable() {
		packetsMap.clear();
	}

	@EventTarget
	public void onPacket(final PacketEvent event) {
		final Packet packet = event.getPacket();

		if ((packet instanceof C0FPacketConfirmTransaction || packet instanceof C00PacketKeepAlive) && !(mc.thePlayer.isDead || mc.thePlayer.getHealth() <= 0) && !packetsMap.containsKey(packet)) {

			synchronized(packetsMap) {
				packetsMap.put(packet, System.currentTimeMillis() + TimeUtils.randomDelay(minDelayValue.get(), maxDelayValue.get()));
			}
			event.cancelEvent();
		}
	}

	@EventTarget(ignoreCondition = true)
	public void onUpdate(final UpdateEvent event) {
		try {
			synchronized(packetsMap) {
				for(final Iterator<Map.Entry<Packet<?>, Long>> iterator = packetsMap.entrySet().iterator(); iterator.hasNext(); ) {
					final Map.Entry<Packet<?>, Long> entry = iterator.next();

					if(entry.getValue() < System.currentTimeMillis()) {
						mc.getNetHandler().addToSendQueue(entry.getKey());
						iterator.remove();
					}
				}
			}
		}catch(final Throwable t) {
			t.printStackTrace();
		}
	}
}
